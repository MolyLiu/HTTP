#第七章 缓存
缓存是可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储谁被而不是原始服务器中提取这个文档。

使用缓存的优点：

- 缓存减少了冗余的数据传输，节省了你的网络费用。
- 缓存缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。
- 缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。
- 缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。
##7.1冗余的数据传输
有很多客户端访问一个流行的原始服务器页面时，服务器会多次传输同一份文档，每次传送给一个客户端。一些相同的字节会在网络中一遍遍地传输。这些冗余的数据传输会耗尽昂贵的网络带宽，降低传输速度，加重Web服务器的负载。

有了缓存，就可以保留第一条服务器响应的副本，后继请求就可以由缓存的副本来应对了，这样可以减少那些流入/流出原始服务器的、被浪费掉了的重复流量。

##7.2 带宽瓶颈
缓存还可以缓解网络的瓶颈问题。

很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽。

客户端会以路径上最慢的网络访问服务器。如果客户端从一个快速局域网的缓存中得到了一份副本，那么缓存就可以提高性能——尤其是要传输比较大的文件时。

##7.3 瞬间拥塞
缓存在破坏**瞬间拥塞**时显得非常重要。

突发事件使很多人几乎同时去访问一个Web文档时，就会出现瞬间拥塞。由此造成的过多流量峰值可能会使网络和Web服务器产生灾难性的崩溃。

##7.4 距离时延
即使带宽不是问题，距离也可能成为问题。

每台网络路由器都会增加因特网流量的时延。即使客户端和服务器之间没有太多的路由器，光速自身也会造成显著的时延。

将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米。

##7.5 命中和未命中的
缓存是有所帮助的，但是缓存无法保存世界上每份文档的副本。

可以用已有的副本为某些到达缓存的请求提供服务，这被称为**缓存命中**。

其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器，这被称为**缓存未命中**。
### 7.5.1 再验证
原始服务器的内容可能会发生改变，缓存要不时对其进行检测，看看它们保存的副本是否仍是服务器上最新的副本。这些“新鲜度检测”被称为**HTTP再验证**。

为了有效地进行在验证，HTTP定义了一些特殊的请求，不用从服务器上获取整个对象，就可以快速检测出内容是否是最新的。

缓存可以在任意时刻，以任意的频率对副本进行在验证。但由于缓存中通常会包含数百万的文档，而且网络带宽是很珍贵的，所以**大部分缓存只有在客户端发起请求，并且副本旧的足以需要验证的时候，才会对副本进行再验证。**

缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的在验证请求。如果内容没有变化，服务器会以一个小的304 Not Modified进行响应。只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端，这被称为**再验证命中**或**缓慢命中**。这种方式确实要与原始服务器进行核对，所以会比单纯的缓存命中要慢，但它没有从服务器中获取对象数据，所以要比缓存未命中快一点。

HTTP为我们提供了几个用来对已缓存对象进行再验证的工具，但是最常用的是If-Modified-Sinece首部。将这个首部添加到GET请求中去，就可以告诉服务器，**只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。**

这里列出了在3种情况下（服务器内容未被球盖，服务器内容已被修改，或者服务器上的对象被删除了）服务器收到了GET If-Modified-Since请求时会发生的情况：

- 再验证命中

	如果服务器对象未被修改，服务器会向客户端发送一个小的HTTP 304 Not Modified响应。

- 再验证未命中

	如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的HTTP 200 OK响应。

- 对象被删除
	
	如果服务器对象已经被删除了，服务器就会送一个404 Not Fount响应，缓存也会将其副本删除。
###7.5.2 命中率
由缓存提供服务的请求所占的比例被称为**缓存命中率**，有时也成为**文档命中率**。

0%表示每次请求都未命中（要通过网络来获取文档），100%表示每次请求都命中了（在缓存中有一份副本）。

缓存的管理者希望缓存命中率接近100%。

但是实际上得到的命中率则与缓存的大小、缓存用户兴趣点的相似性、缓存数据的变化或个性化频率，以及如何配置缓存有关。

命中率很难预测，但对现在中等规模的Web缓存来说，40%命中率是很合理的。

缓存的好处是，即使是中等规模的缓存，其所包含的常见文档也足以显著地提高性能、减少流量了。

缓存会努力确保将有用的内容保存在缓存中。

###7.5.3字节命中率
由于文档并不全是同一尺寸的，所以文档命中率并不能说明一切。有些大型对象被访问的次数可能较少，但由于尺寸的原因，对整个数据流量的贡献却更大。

所以用字节命中率作为度量值也有的。

**字节命中率**表示的是缓存提供的字节在传输的所有字节中所占的比例。通过这种度量方式，可以得知节省流量的程度。100%的字节命中率说明每个字节都来自缓存，没有流量留到因特网上去。

文档命中率和字节命中率对缓存性能的评估都是很有用的。

文档命中率说明阻止了多少通往外部网络的Web事务。事务有一个通常都很大的固定时间成分（比如，建立一条到服务器的TCP连接），提高文档命中率对**降低整体延迟**（时延）很有好处。

字节命中率说明阻止了多少字节传向因特网。提高字节命中率对**节省带宽**很有利。

###7.5.4 区分命中和未命中的情况
HTTP并没有为用户提供一种手段来区分响应式缓存命中的，还是访问原始服务器得到的。在这两种情况下，响应码都是200 OK，说明响应有主体部分。

有些商业代理缓存会在Via首部附加一些额外信息，以描述缓存中发生的情况。

客户端有一种方法可以判断响应是否来自缓存，就是使用Date首部。将响应中Date首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可以认为这是一条缓存响应。

客户端也可以通过Age首部来检测缓存的响应，通过这个首部可以分辨出这条响应的试用期。
##7.6 缓存的拓扑结构
缓存可以是单个用户专用的，也可以是数千名用户共享的。

专用缓存被称为**私有缓存**。私有缓存是个人的缓存，包含了单个用户最常见的页面。

共享缓存被称为公有缓存，公有缓存包含了某个用户团体的常用页面。
###7.6.1 私有缓存
私有缓存不需要很大的动力或存储空间，这样就可以将其做的很小很便宜。

Web浏览器中有内建的私有缓存——大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中，并且允许用户去配置缓存的太小和各种设置。

###7.6.2 公有代理缓存
公有缓存是特殊的共享代理服务器，被称为**缓存代理服务器**，或者更常见的被称为**代理缓存**。

代理缓存会从本地缓存中提供文档，或者代表用户与服务器进行联系。公有缓存会接受来自多个用户的访问，所以通过它可以更好地减少冗余流量。

###7.6.3 代理缓存的层次结构
在实际中，实现**层次化**的缓存是很有意义的，在这种结构中，在较小缓存中未命中的请求会被导向较大的**父缓存**，由它来为剩下的那些“提炼过的”流量提供服务。

其基本思想是在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能更强的缓存来装载多用户共享的文档。

在缓存层次结构很深的情况下，请求可能要穿过很长一溜缓存，但每个拦截代理都会添加一些性能损耗，当代理链路变得很长的时候，这种性能损耗会变得非常明显。

在实际中，网络结构会尝试着将其深度限制在连续的两到三个代理以内，但是新一代的高性能代理服务器会使代理链的长度变得不那么重要。

###7.6.4 网状缓存、内容路由以及对等缓存
有些网络结构会构建复杂的**网状缓存**，而不是简单的缓存层次结构。网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的缓存通信决策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。这种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可以将它称为**内容路由器**。

网状缓存中为内容路由设计的缓存要完成下列所有功能

- 根据URL在父缓存或原始服务器之间进行动态选择。
- 根据URL动态地选择一个特定的父缓存。
- 前往父缓存之前，在本地缓存中搜索已缓存的副本。
- 允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过它们的缓存。

缓存之间这些更为复杂的关系允许不同的组织互为**对等实体**，将它们的缓存连接起来以实现共赢。提供可选的对等支持的缓存被称为**兄弟缓存**。

HTTP并不支持兄弟缓存，所以人们通过一些协议对HTTP进行了扩展，比如ICP,HTCP

##7.7 缓存的处理步骤
对一条HTTP GET报文的基本缓存处理过程包括7个步骤
![](https://i.imgur.com/nrVQMtt.png)

1. 接收——缓存从网络中读取抵达的请求报文。
2. 解析—— 缓存对报文进行解析，提取出URL和各种首部。
3. 查询 —— 缓存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保存在本地）。
4. 新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。
5. 创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。
6. 发送——缓存通过网络将响应发回给客户端。
7. 日志——缓存可选地创建一个日志文件条目来描述这个事务。

###7.7.1 第一步——接收
在第一步中，缓存检测到一条网络连接上的活动，读取输入数据。高性能的缓存会同时从多条输入连接上读取数据，在整条报文抵达之前开始对事务进行处理。
###7.7.2 第二步——解析
接下来，缓存将请求报文解析为片段，将首部的各个部分放入易于操作的数据结构中。这样，缓存软件就更容易处理首部字段并修改它们了。
###7.7.3 第三步——查找
在第三步中，缓存获取了URL，查找本地副本。

本地副本可能存储在内存、本地磁盘，甚至附近的另一台计算机中。专业级的缓存会使用快速算法来确定本地缓存中是否有某个对象。

已缓存对象中包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中时返回正确的服务器首部。

已缓存对象中还包含了一些**元数据**，用来记录对象在缓存中停留了多久，以及被使用了多少次。
### 7.7.4 第四步——新鲜度检测
HTTP通过缓存将服务器文档的副本保留一段时间。

在这段时间里，都认为文档是“新鲜的”，缓存可以在不联系服务器的情况下，直接提供该文档。但一旦已缓存副本停留的时间太行，超过了文档的**新鲜度限值**，就认为对象“过时”了，在提供该文档之前，缓存要再次与服务器进行确认，以查看文档是否发生了变化。

###7.7.5 第五步——创建响应
我们希望缓存的响应看起来就像是来自原始服务器的一样，缓存将已缓存的服务器响应首部作为响应首部的起点。然后缓存对这些基础首部进行了修改和扩充。

缓存负责对这些首部进行改造，以便于客户端的要求匹配。

缓存不应该调整Date首部，date首部表示的是原始服务器最初产生这个对象的日期。
###7.7.6 第六步——发送
一旦响应首部准备好了，缓存就将响应会送给客户端。和所有代理服务器一样，代理缓存要管理与客户端之间的连接。高性能的缓存会尽力高效地发送数据，通常可以避免在本地缓存和网络I/O缓冲区之间进行文档内容的复制。
###7.7.7 第七步——日志
大多数缓存都会保存日志文件以及与缓存的使用有关的一些统计数据。

##7.8 保持副本的新鲜
HTTP有一些简单的机制可以再不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。HTTP将这些简单的机制成为**文档过期**和**服务器再验证**。
###7.8.1 文档过期
![](https://i.imgur.com/wtPiJTk.png)
通过特殊的HTTP Cache-Control首部和Expires首部，HTTP让原始服务器向每个文档附加了一个“过期日期”。这些首部说明了在多长时间内可以将这些内容视为新鲜的。

在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系————当然，除非客户端请求中包含有阻止提供已缓存或未验证资源的首部。

但一旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果被修改过，就要获取一份新鲜的副本。
###7.8.2 过期日期和使用期
绝对日期
###7.8.3 服务器再验证
仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际区别；这只是意味着到了要进行核对的时间了。这种情况被称为“**服务器再验证**”，说明缓存需要**询问**原始服务器文档是否发生了变化。

- 如果再验证显示**内容发生了变化**，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。
- 如果再验证显示**内容没有发生变化**，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。

缓存并不一定要为每条请求验证文档的有效性————只有在文档过期时它才需要与服务器进行再验证。
###7.8.4 用条件方法进行再验证
HTTP条件方法可以高效地实现再验证。HTTP允许缓存向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中的现有副本不同时，才回送对象主体。

通过这种方式，将新鲜度检测和对象获取结合成了单个条件GET。向GET请求报文中添加一些特殊的条件首部，就可以发起条件GET。只有条件为真时，Web服务器才会返回对象。
###7.8.5  If-Modified-Since:Date再验证
最常见的缓存再验证首部是If-Modified-Since。它通常被称为IMS请求。只有自某个日期之后资源发生了变化的时候，IMS请求才会指示服务器执行请求：

- 如果自指定日期后，文档被修改了，If-Modified-Since条件就为真，通常GET就会成功执行。携带新首部的新文档会返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。
- 如果自指定日期后，文档没被修改过，条件就为假，会向客户端返回一个小的304 Not Modified响应报文，为了提高有效性，不会返回文档的主体。

###7.8.6 If-None-Match:实体标签再验证
有些情况下仅使用最后修改日期进行再验证是不够的：

- 有些文档可能会被周期性地重写（比如，从一个后台进程中写入），但实际上包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。
- 有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据（比如对拼写或注释的修改）。
- 有些服务器无法准确地判定其页面的最后修改日期。
- 有些服务器提供的文档会在亚秒间隙发生变化（比如，实时监视器），对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。

为了解决这些问题，HTTP允许用户对被称为**实体标签**的“版本标识符”进行比较。

实体标签是附加到文档上的任意标签（引用字符串）。它们可能包含了文档的序列号或版本号，或者是文档内容的校验和其他指纹信息。

当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样，如果实体标签被修改了，缓存就可以用If-None-Match条件首部来GET文档的新副本。
###7.8.7 强弱验证器
缓存可以用实体标签来判断，与服务器相比，已缓存版本是不是最新的（与使用最近修改日期的方式很像）。从这个角度来看，实体标签和最近修改日期都是**缓存验证器**。

有时，服务器希望在对文档进行一些非实质性或不重要的修改时，不要使所有的已缓存副本都失效。HTTP/1.1支持“弱验证器”。

只要内容发生了变化，强验证器就会变化。弱验证器允许对一些内容进行修改，但内容的主要含义发生变化时，通常它还是会变化的。

注意，原始服务器一定不能为两个不同的实体重用一个特定的强实体标签值，或者为两个语义不同的实体重用一个特定的弱实体标签值。
###7.8.7 什么时候应该使用实体标签和最近修改日期
如果服务器回送了一个实体标签，HTTP/1.1客户端就必须使用实体标签验证器。

如果服务器只回送了一个Last-Modified值，客户端就可以使用If-Modified-Since验证。

如果实体标签和最后修改日期都提供了，客户端就应该使用这两种再验证方案，这样HTTP/1.0和HTTP/1.1缓存就都可以正确响应了。

##7.9 控制缓存的能力
服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序，服务器可以：

- 附加一个Cache-Controller:no-store首部到响应中去。
- 附加一个Cache-Controller:no-cache首部到响应中去。
- 附加一个Cache-Controller:must-revalidate首部到响应中去。
- 附加一个Cache-Controller:max-age首部到响应中去。
- 附加一个Expires日期首部到响应中去。
- 不附加过期信息，让缓存确定自己的过期日期。


###7.9.1 no-Store和no-Cache响应首部

no-Store和no-Cache响应首部可以防止缓存提供未经证实的已缓存对象。

标识为no-store的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条no-store响应，然后删除对象。

标识为no-cahce的响应实际上是可以存储在本地缓存区中的。只是在原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。
###7.9.2 max-age响应首部
Cache-Controller:max-age首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。还有一个s-maxage首部，其行为与max-age类似，但仅适用于共享缓存。


###7.9.3 Expires响应首部
不推荐使用，它指定的是实际的过期日期而不是秒数。
###7.9.4 must-revalidate响应首部
可以配置缓存，使其提供一些陈旧过期的对象，以提高性能。如果原始服务器希望缓存严格遵守过期信息，可以在原始响应中附加一个Cache-Control:must-revalidate首部。告诉缓存，在事先没有跟原始服务器进行再验证的情况下，不能提供这个对象的陈旧副本。
###7.9.5试探性过期
如果响应中没有Cache-Control:max-age首部，也没有Expires首部，缓存可以计算出一个试探性最大使用期。

LM-Factor算法是一种很常用的试探性过期算法，如果文档中包含了最后修改日期，就可以使用这种算法。LM-Factor算法将最后的修改日期作为依据，来估计文档有多么异变。算法的逻辑如下所示：

- 如果已缓存文档最后一次修改发生在很久以前，它可能会是一份稳定的文档，不太会突然发生变化，因此将其继续保存在缓存中会比较安全。
- 如果已缓存文档最近被修改过，就说明它很可能会频繁地发生变化，因此在与服务器进行再验证之前，只应该将其缓存很短一段时间。
###7.9.6 客户端的新鲜度限制
Web浏览器都有Refresh刷新或Reload重载按钮，可以强制对浏览器或代理缓存中可能过期的内容进行刷新。

Refresh按钮会发布一个附加了Cache-Control请求首部的GET请求，这个请求会强制进行再验证，或者无条件地从服务器获取文档。

Refresh的确切行为取决于特定的浏览器、文档以及拦截缓存的配置。
###7.9.7 注意事项
文档过期系统并不是一个完美的系统。如果发布者不小心分配了一个很久之后的过期日期，在文档过期之前，她要对文档做的所有修改都不会出现在任何缓存中。因此，很多发布者都不会使用很久的过期日期。而且，很多发布者甚至都不使用过期日期，这样缓存就很难确定文档会在多长时间内保持新鲜了。

##7.10 设置缓存控制
。。

##7.12 缓存和广告
缓存可以提高性能并减少流量。缓存可以帮助用户，并为用户提供更好的使用体验。